# 变量与常量
## 声明方式
### 变量声明方式
``` golang
var name type = value
var name =value
name := value

```
### 常量声明方式

``` golang
const name type = value
const (
	c1 = 2
	c2 //=2
	c3//=2
	c4 = 6
	c5//=6
)
```
## 命名规则
1. 大/小写字母开头 控制是否可包外访问
## 可多重赋值
``` golang
var  a,b int =10,5
a,b=b,a// 交换ab值
```

## 匿名变量
> 例如函数返回两个返回值  可以用 _ 符号排除
```golang

getUserInfo()(name string,age int){
    return "tom",18
}
_,age=getUserInfo()//只获取age
```
# 数据类型
## 基本数据类型
1. 布尔类型：bool
2. 整型：int8、byte、int16、int、uint、uintptr 等
3. 浮点类型：float32、float64
4. 复数类型：complex64、complex128
5. 字符串：string
6. 字符类型：rune
7. 错误类型：error

## 复合数据类型
1. 指针（pointer）
2. 数组（array）
3. 切片（slice）
4. 字典（map）
5. 通道（chan）
6. 结构体（struct）
7. 接口（interface）

## 布尔类型
> 只能是true 或false 不可以 是 0~1的整型转换

## 整型及运算符

### 整形
> 注: int和int64是两种不同类型  ，编译器也不会帮你自动做类型转换  可以 类型(变量) 做强制转换
> 和其他编程语言一样，可以通过增加前缀 0 来表示八进制数（如：077），增加前缀 0x 来表示十六进制数（如：0xFF），以及使用 E 来表示 10 的连乘（如：1E3 = 1000）。
#### 有符号位
1. int8
2. int16
3. int32
4. int64
#### 无符号位
1. uint8
2. uint16
3. uint32
4. uint64

### 运算符

#### 算术运算符
> + - * / %  (%只能用于整数)
> 不同类型的整型值不能直接进行算术运算
> 在 Go 语言中，也支持自增/自减运算符，即 ++/--，但是只能作为语句，不能作为表达式，且只能用作后缀，不能放到变量前面：
> 支持 +=、-=、*=、/=、%= 这种快捷写法

#### 比较运算符
> Go语言支持一下集中常见的比较运算符: > < == >= <= 和!= 比较运算符运行的结果是布尔值
> 各种类型的整形变量都可以直接与字面常量进行比较 intValue==8
#### 逻辑运算符
> 逻辑运算符计算的结果也是布尔值，通常我们可以组合使用逻辑运算符和比较运算符：
| 运算符 | 含义                | 结果                                                   |
| :----- | :------------------ | :----------------------------------------------------- |
| x && y | 逻辑与运算符(AND)   | 如果 x 和 y 都是 true，则结果为 true，否则结果为 false |
| x      |                     | y                                                      | 逻辑或运算符（OR） | 如果 x 或 y 是 true，则结果为 true，否则结果为 false |
| !x     | 逻辑非运算符（NOT） | 如果 x 为 true，则结果为 false，否则结果为 true        |
#### 位运算符
> 位运算符以二进制的方式对数值进行运算，效率更高，性能更好，Go 语言支持以下这几种位运算符

| 运算符 | 含义     | 结果                                           |
| :----- | :------- | :--------------------------------------------- |
| x & y  | 按位与   | 把 x 和 y 都为 1 的位设为 1                    |
| x      | y        | 按位或                                         | 把 x 或 y 为 1 的位设为 1 |
| x ^ y  | 按位异或 | 把 x 和 y 一个为 1 一个为 0 的位设为 1         |
| ^x     | 按位取反 | 把 x 中为 0 的位设为 1，为 1 的位设为 0        |
| x << y | 左移     | 把 x 中的位向左移动 y 次，每次移动相当于乘以 2 |
| x >> y | 右移     | 把 x 中的位向右移动 y 次，每次移动相当于除以 2 |

#### 运算符优先级
> 上面介绍的 Go 语言运算符优先级如下所示（由上到下表示优先级从高到低，或者数字越大，优先级越高）：
> ++ 或 -- 只能出现在语句中，不能用于表达式，故不参与优先级判断。
1. 6      ^（按位取反） !
2. 5      *  /  %  <<  >>  &  &^
3. 4      +  -  |  ^（按位异或）
4. 3      ==  !=  <  <=  >  >=
5. 2      &&
6. 1      ||

## 浮点型与复数类型

### 浮点型
> Go 语言中的浮点数采用IEEE-754 标准的表达方式，定义了两个类型：float32 和 float64，其中 float32 是单精度浮点数，可以精确到小数点后 7 位（类似 PHP、Java 等语言的 float 类型），float64 是双精度浮点数，可以精确到小数点后 15 位（类似 PHP、Java 等语言的 double 类型）。
> 浮点数支持通过算术运算符进行四则运算，也支持通过比较运算符进行比较（前提是运算符两边的操作数类型一致），但是涉及到相等的比较除外，因为我们上面提到，看起来相等的两个十进制浮点数，在底层转化为二进制时会丢失精度
> 如果一定要判断相等，下面是一种替代的解决方案：
> 通过一个可以接受的最小误差值 p，约定如果两个浮点数的差值在此精度的误差范围之内，则判定这两个浮点数相等

### 复数类型
> 除了整型和浮点型之外，Go 语言还支持复数类型，与复数相对，我们可以把整型和浮点型这种日常比较常见的数字称为实数，复数是实数的延伸，可以通过两个实数（在计算机中用浮点数表示）构成，一个表示实部（real），一个表示虚部（imag），常见的表达形式如下：
> z = a + bi
> 其中 a、b 均为实数，i 称为虚数单位，当 b = 0 时，z 就是常见的实数，当 a = 0 而 b ≠ 0 时，将 z 称之为纯虚数，如果你理解数学概念中的复数概念，这些都很好理解，下面我们来看下复数在 Go 语言中的表示和使用。
> 在 Go 语言中，复数支持两种类型：complex64（32 位实部和虚部） 和 complex128（64 位实部与虚部），对应的表示示例如下，和数学概念中的复数表示形式一致：

## 字符串及底层字符类型
### 字符串
> 在 Go 语言中，字符串是一种基本类型，默认是通过 UTF-8 编码的字符序列，当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节，比如中文编码通常需要 3 个字节。

#### 声明和初始化
``` golang
var str string         // 声明字符串变量
str = "Hello World"    // 变量初始化
str2 := "你好，学院君"   // 也可以同时进行声明和初始化
```
#### 格式化输出
> 还可以通过 Go 语言内置的 len() 函数获取指定字符串的长度，以及通过 fmt 包提供的 Printf 进行字符串格式化输出：
``` golang
fmt.Printf("The length of \"%s\" is %d \n", str, len(str)) 
fmt.Printf("The first character of \"%s\" is %c.\n", str, ch)
```
#### 转义字符
Go 语言的字符串不支持单引号，只能通过双引号定义字符串字面值，如果要对特定字符进行转义，可以通过 \ 实现，就像我们上面在字符串中转义双引号和换行符那样，常见的需要转义的字符如下所示：
1. \n ：换行符
2. \r ：回车符
3. \t ：tab 键
4. \u 或 \U ：Unicode 字符
5. \\\ ：反斜杠自身
> 也可以使用 `` 的方式

#### 多行字符串
> 对于多行字符串，也可以通过 ` 构建：  如果使用+号链接的话 +号要留在上一行

#### 不可变值类型
> 虽然可以通过数组下标方式访问字符串中的字符但是和数组不同，在 Go 语言中，字符串是一种不可变值类型，一旦初始化之后，它的内容不能被修改，比如看下面这个例子：
``` golang
str := "Hello world"
str[0] = 'X' // 编译错误
```
### 字符串操作
#### 字符串连接
> Go 内置提供了丰富的字符串函数，常见的操作包含连接、获取长度和指定字符，获取长度和指定字符前面已经介绍过，字符串连接只需要通过 + 连接符即可
> 如果字符串长度较长，需要换行，则 + 连接符必须出现在上一行的末尾，否则会报错：
#### 字符串切片
> 在 Go 语言中，可以通过字符串切片实现获取子串的功能：
> Go 切片区间可以对比数学中的区间概念来理解，它是一个左闭右开的区间，比如上述 str[0:5] 对应到字符串元素的区间是 [0,5)，str[:5] 对应的区间是 [0,5)（数组索引从 0 开始），str[7:] 对应的区间是 [7:len(str)]（这是闭区间，是个例外，因为没有指定区间结尾）
> :index 代表index 0~index 不含index
> index:代表 index~结束 包含index
> 包头不包尾
> str[:] 会打印出完整的字符串来。
>  Go 字符串也支持字符串比较、是否包含指定字符/子串、获取指定子串索引位置、字符串替换、大小写转换、trim 等操作，更多操作 API 参考标准库 strings 包，

#### 字符串遍历
> Go 语言支持两种方式遍历字符串。
1. 以字节数组的方式遍历
2. 以 Unicode 字符遍历

### 底层字符类型
> Go 语言对字符串中的单个字符进行了单独的类型支持，在 Go 语言中支持两种字符类型
> 1. byte，代表 UTF-8 编码中单个字节的值（它也是 uint8 类型的别名，两者是等价的，因为正好占据 1 个字节的内存空间
> 2. rune，代表单个 Unicode 字符（它也是 int32 类型的别名，因为正好占据 4 个字节的内存空间。关于 rune 相关的操作，可查阅 Go 标准库的 unicode 包）。

#### UTF-8 和 Unicode 的区别
> Unicode 是一种字符集，囊括了目前世界上所有语言的所有字符，与之类似的术语还有 ASCII 字符集（仅包含 256 个字符）、ISO 8859-1 字符集等（包含所有西方拉丁字母），广义的 Unicode 既包含了字符集，也包含了编码规则，比如 UTF-8、UTF-16、UTF8MB4、GBK 等。
> 因此 UTF-8 是 Unicode 字符集的实现方式之一，它会将 Unicode 字符以某种方式进行编码。在具体实现时，UTF-8 是一种变长的编码规则，从 1~4 个字节不等，比如英文字符是 1 个字节，中文字符是 3 个字节。通过 UTF-8 编码的 Unicode 字符以最大长度 4 个字节作为单个字符固定占据的内存空间，在 Go 语言中可以通过 unicode/utf8 包进行 UTF-8 和 Unicode 之间的转换。
> 所以如果从 Unicode 字符集的视角看，字符串的每个字符都是一个字符的独立单元，但如果从 UTF-8 编码的视角看，一个字符可能是由多个字节编码而来的。
> 我们通过 len 函数获取到的是字符串的字节长度，再据此通过字符数组的方式遍历字符串时，是以 UTF-8 编码的角度切入的；而当我们通过 range 关键字遍历字符串时，又是从 Unicode 字符集的角度切入的，如此一来就得到了不同的结果。
> 出于简化语言的考虑，Go 语言的多数 API 都假设字符串为 UTF-8 编码。

#### 将 Unicode 编码转化为可打印字符
> 如果你想要将 Unicode 字符编码转化为对应的字符，可以使用 string 函数进行转化

## 基本数据类型之间的转化
>  Go 语言中的基本数据类型，分别是布尔类型、整型、浮点型、复数类型、字符串和字符类型
### 数值类型之间的转化
> 像这样直接用要转换的类型包裹即可
> 需要注意在有符号与无符号以及高位数字向低位数字转化时，需要注意数字的溢出和截断。
``` golang
uint()
int64()
```
#### 整型之间的转化


##### 整型与浮点型之间的转化
> 浮点型转化为整型时，小数位被丢弃：
> 整型转化为浮点型时，直接调用对应的函数即可：

##### 数值和布尔类型之间的转化
>  Go 语言不支持将数值类型转化为布尔型，你需要自己根据需求去实现类似的转化。

### 字符串和其他基本类型之间的转化
#### 将整型转化为字符串
> 整型数据可以通过 Unicode 字符集转化为对应的 UTF-8 编码的字符串
> 还可以将 byte 数组或者 rune 数组转化为字符串，因为字符串底层就是通过这两个基本字符类型构建的

#### strconv 包
> Go 语言默认不支持将字符串类型强制转化为数值类型，即使字符串中包含数字也不行。
> 如果要实现更强大的基本数据类型与字符串之间的转化，可以使用 Go 官方 strconv 包提供的函数

##  数组使用入门及其不足

### 数组的声明和初始化
> 数组是所有语言编程中最常用的数据结构之一，Go 语言也不例外，与 PHP、JavaScript 等弱类型动态语言不同，在 Go 语言中，数组是固定长度的、同一类型的数据集合。数组中包含的每个数据项被称为数组元素，一个数组包含的元素个数被称为数组的长度。 和java一样
> 在 Go 语言中，你可以通过 [] 来标识数组类型，但需要指定长度和元素类型。以下是一些常见的数组声明方法：
``` golang
var a [8]byte // 长度为8的数组，每个元素为一个字节
var b [3][3]int // 二维数组（9宫格）
var c [3][3][3]float64 // 三维数组（立体的9宫格）
var d = [3]int{1, 2, 3}  // 声明时初始化
var e = new([3]string)   // 通过 new 初始化
//数组的格式定义如下所示:
//[capacity]data_type{element_values}
//还可以通过这种语法糖省略数组长度的声明：
a := [...]int{1, 2, 3}
//数组在初始化的时候，如果没有填满，则空位会通过对应的元素类型零值填充：
//我们还可以初始化指定下标位置的元素值，未设置的位置也会以对应元素类型的零值填充：
a := [5]int{1: 3, 3: 7}
//[0 3 0 7 0]
```
## 切片使用入门与数据共享问题处理
> 数组的一个特点：数组的长度在定义之后无法修改，数组长度是数组类型本身的一部分，是数组的一个内置常量，因此我们无法在数组上做动态的元素增删操作。
> Go语言提供了切片（slice）来弥补数组的不足，切片一个最强大的功能就是支持对元素做动态增删操作

### 切片的定义
> 在 Go 语言中，切片是一个新的数据类型，与数组最大的不同在于，切片的类型字面量中只有元素的类型，没有长度：
> 因此它是一个可变长度的、同一类型元素集合，切片的长度可以随着元素数量的增长而增长（但不会随着元素数量的减少而减少），不过切片从底层管理上来看依然使用数组来管理元素，可以看作是对数组做了一层简单的封装。基于数组，切片添加了一系列管理功能，可以随时动态扩充存储空间  
> 类似于Java 集合中的 List

### 创建切片
> 创建切片的方法主要有三种 —— 基于数组、切片和直接创建
#### 基于数组
>切片可以基于一个已存在的数组创建。从这个层面来说，数组可以看作是切片的底层数组，而切片则可以看作是数组某个连续片段的引用。切片可以只使用数组的一部分元素或者整个数组来创建，甚至可以创建一个比所基于的数组还要大的切片
``` golang
// 先定义一个数组
months := [...]string{"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
// 基于数组创建切片  包头不包尾
q2 := months[3:6]    // 第二季度
summer := months[5:8]  // 夏季
fmt.Println(q2)
fmt.Println(summer)   
```
> Go 语言支持通过 array[start:end] 这样的方式基于数组生成一个切片，start 表示切片在数组中的下标起点，end 表示切片在数组中的下标终点，两者之间的元素就是切片初始化后的元素集合，通过上面的示例可以看到，和字符串切片一样，这也是个左闭右开的集合，下面几种用法也都是合法的：

``` golang
// 全部元素
all := months[:]
//前六个元素
firsthalf := months[:6]
//第六个元素开始的后续元素
secondhalf := months[6:]
```

> 切片底层引用了一个数组，由三个部分构成 —— 指针、长度和容量，指针指向数组起始下标，长度对应切片中元素的个数，容量则是切片起始位置到底层数组结尾的位置：
> 切片长度不能超过容量，比如上面的数组切片 q2，其指针指向底层数组 months 下标为 3 的位置，切片长度是3，切片容量是9（从下标 3 开始到下标 11 结束，可容纳 9 个元素），和数组一样，我们可以通过内置函数 len 获取切片的长度，此外还可以通过 cap 函数获取切片容量：
``` golang
fmt.Println(len(q2))   // 3
fmt.Println(cap(q2))   // 9
```

#### 基于切片
``` golang
//类似于切片可以基于一个数组创建，切片也可以基于另一个切片创建：
firsthalf := months[:6]
q1 := firsthalf[:3] // 基于 firsthalf 的前 3 个元素构建新切片
//基于 firsthalf 创建切片时，选择的 firsthalf 元素范围可以超过所包含的元素个数，比如 q1 可以基于firsthalf 的前 9 个元素创建：
```
#### 直接创建
并非一定要事先准备一个数组才能创建切片，Go 语言提供的内置函数 make() 可以用于灵活地创建切片。

例如要创建一个初始长度为 5 的整型切片，可以这么做：

``` golang
mySlice1 := make([]int, 5)
```

要创建一个初始长度为 5、容量为 10 的整型切片，可以这么做（通过第三个参数设置容量）：

``` golang
mySlice2 := make([]int, 5, 10)
```
此外，还可以直接创建并初始化包含 5 个元素的数组切片（长度和容量均为5）：
``` golang
mySlice3 := []int{1, 2, 3, 4, 5}
//和数组一样，所有未初始化的切片，会填充元素类型对应的零值。
```

### 遍历切片
> 由于切片可以看作是是数组指针，因此，操作数组元素的所有方法都适用于切片，比如切片也可以按下标读写元素，用 len() 函数获取元素个数，并支持使用 range 关键字来快速遍历所有元素。
传统的元素遍历方法如下:
``` golang
for i := 0; i < len(summer); i++ {
    fmt.Println("summer[", i, "] =", summer[i]) 
}
```
使用 range 关键字可以让遍历代码显得更简洁，range 表达式有两个返回值，第一个是索引，第二个是元素的值：
``` golang

for i, v := range summer { 
    fmt.Println("summer[", i, "] =", v) 
}
```
### 动态增加元素	
> 切片比数组更强大之处在于支持动态增加元素，甚至可以在容量不足的情况下自动扩容。在切片类型中，元素个数和实际可分配的存储空间是两个不同的值，元素的个数即切片的实际长度，而可分配的存储空间就是切片的容量。
> 一个切片的容量初始值根据创建方式的不同而不同：
>- 对于基于数组和切片创建的切片而言，默认容量是从切片起始索引到对应底层数组的结尾索引
>- 对于通过内置 make 函数创建的切片而言，在没有指定容量参数的情况下，默认容量和切片长度一致。
> 所以，通常一个切片的长度值小于等于其容量值，我们可以通过 Go 语言内置的 cap() 函数和 len() 函数来获取某个切片的容量和实际长度：
> 我们可以通过 append() 函数向切片追加新元素：
``` golang

var oldSlice = make([]int, 5, 10)

fmt.Println("len(oldSlice):", len(oldSlice)) //5
fmt.Println("cap(oldSlice):", cap(oldSlice)) //10
newSlice := append(oldSlice, 1, 2, 3)
```

#### 内容复制
> 切片类型还支持 Go 语言的另一个内置函数 copy()，用于将元素从一个切片复制到另一个切片。如果两个切片不一样大，就会按其中较小的那个切片的元素个数进行复制。

``` golang
slice1 := []int{1, 2, 3, 4, 5} 
slice2 := []int{5, 4, 3}
// 复制 slice1 到 slice 2
copy(slice2, slice1) // 只会复制 slice1 的前3个元素到 slice2 中
// slice2 结果: [1, 2, 3]
// 复制 slice2 到 slice 1
copy(slice1, slice2) // 只会复制 slice2 的 3 个元素到 slice1 的前 3 个位置
// slice1 结果：[5, 4, 3, 4, 5]
```
### 动态删除元素
> 切片除了支持动态增加元素之外，还可以动态删除元素，在切片中动态删除元素可以通过多种方式实现（其实是通过切片的切片实现的「伪删除」）：

## 字典使用入门与字典排序实现

### 字典声明和初始化

#### 字典声明
``` golang
var testMap map[string]int
//testMap 是声明的字典变量名，
//string 是键的类型，
//int 则是其中所存放的值类型。

```
#### 字典初始化
> 我们可以通过先声明再初始化的方式进行初始化，就像上面示例代码做的那样，也可以通过 := 将声明和初始化合并为一条语句：
``` golang
testMap := map[string]int{
  "one": 1,
  "two": 2,
  "three": 3,
}
```
> 通过 Go 语言内置的函数 make() 来初始化一个新字典：

``` golang
var testMap = make(map[string]int)
```
> 通过这种方式初始化后，可以往字典中添加键值对（前面那种声明方式不能这么操作，否则编译期间会抛出 panic）：
``` golang
testMap["one"] = 1
testMap["two"] = 2
testMap["three"] = 3
```
> 还可以通过 make 函数的第二个参数选择是否在创建时指定该字典的初始存储容量（超出会自动扩容）：
``` golang
testMap = make(map[string]int, 100)
```
### 使用入门

#### 元素赋值
``` golang

//赋值过程非常简单明了，只需为给定键赋值即可：
testMap["four"] = 4
//需要注意的是，字典初始化之后才能进行赋值操作，如果仅仅是声明，此时 testMap 的值为 nil，在 nil 上进行操作编译期间会报 panic（运行时恐慌），导致编译不通过。
```
#### 查找元素
> 在 Go 语言中，字典的查找功能设计得比较精巧，要从字典中查找一个特定的键对应的值，可以通过下面的代码来实现：
``` golang
value, ok := testMap["one"] 
if ok { // 找到了
  // 处理找到的value 
}
```
> 从字典中查找指定键时，会返回两个值，第一个是真正返回的键值，第二个是是否找到的标识，判断是否在字典中成功找到指定的键，不需要检查取到的值是否为 nil，只需查看第二个返回值 ok，这是一个布尔值，如果查找成功，返回 true，否则返回 false，配合 := 操作符，让你的代码没有多余成分，看起来非常清晰易懂。
#### 删除元素
> Go 语言提供了一个内置函数 delete()，用于删除容器内的元素，我们可以通过这个函数来实现字典元素的删除：
``` golang
delete(testMap, "four")
```
> 上面的代码将会从 testMap 中删除键为「four」的键值对。如果「four」这个键不存在或者字典尚未初始化，这个调用也不会有什么副作用。



### 字典排序


## 指针使用入门与 unsafe.Pointer

### 指针简介
  我们已经知道，变量的本质对一块内存空间的命名，我们可以通过引用变量名来使用这块内存空间存储的值，而指针则是用来指向这些变量值所在内存地址的值。
  > 注：变量值所在内存地址的值不等于该内存地址存储的变量值。
### 简单示例
``` golang 
a := 100
var ptr *int  // 声明指针类型
ptr = &a      // 初始化指针类型值为变量 a 
fmt.Println(ptr) //0xc0000a2000
fmt.Println(*ptr) //100
```
上面代码中的 ptr 就是一个指针类型，表示指向存储 int 类型值的指针。ptr 本身是一个内存地址值，所以需要通过内存地址进行赋值（通过 &a 可以获取变量 a 所在的内存地址），赋值之后，可以通过 *ptr 获取指针指向内存地址存储的变量值（我们通常将这种引用称作「间接引用」）

### 使用场景
指针在 Go 语言中有两个典型的使用场景：
- 类型指针
- 切片

作为类型指针时，允许对这个指针类型数据指向的内存地址存储值进行修改，传递数据时如果使用指针则无须拷贝数据从而节省内存空间，此外和 C 语言中的指针不同，Go 语言中的类型指针不能进行偏移和运算，因此更为安全。

### 基本使用
#### 指针类型的声明和初始化

指针变量在传值时之所以可以节省内存空间，是因为指针指向的内存地址的大小是固定的，在 32 位机器上占 4 个字节，在 64 位机器上占 8 个字节，这与指针指向内存地址存储的值类型无关。

``` golang

import "fmt"

func main() {
	var ptr *int
	fmt.Printf("ptr: %v\n", ptr)
	a := 32
	ptr = &a
  // a:32
  // ptr:=&a
	fmt.Printf("ptr: %v\n", ptr)
	fmt.Printf("ptr: %v\n", *ptr)
}

```
> 当指针被声明后，没有指向任何变量内存地址时，它的零值是 nil，然后我们可以通过在给定变量前加上取地址符 & 获取该变量对应的内存地址，再将其赋值给声明的指针类型，这样，就完成对指针类型的初始化了，接下来我们可以通过在指针类型前加上间接引用符 * 获取指针指向内存空间存储的变量值。

#### 通过指针传值
> 通过指针传值就类似于 PHP/Java 中通过引用传值，这样做的好处是节省内存空间，此外还可以在调用函数中实现对变量值的修改，因为直接修改的是指针指向内存地址上存储的变量值，而不是值拷贝。

``` golang
func swap(a, b *int)  {
    *a, *b = *b, *a
    fmt.Println(*a, *b)
}
func main() {
    a := 1
    b := 2
    swap(&a, &b)
    fmt.Println(a, b)
}

//2 1
//2 1
```
### unsafe.Pointer
> 我们前面介绍的指针都是被声明为指定类型的，而 unsafe.Pointer 是特别定义的一种指针类型，它可以包含任意类型变量的地址（类似 C 语言中的 void 类型指针）。Go 官方文档对这个类型有如下四个描述：
1. 任何类型的指针都可以被转化为 unsafe.Pointer
2. unsafe.Pointer 可以被转化为任何类型的指针；
3. uintptr 可以被转化为 unsafe.Pointer
4. unsafe.Pointer 可以被转化为 uintptr。

#### 指针类型转化
> 因此，unsafe.Pointer 可以在不同的指针类型之间做转化，从而可以表示任意可寻址的指针类型：


``` golang
i := 10
var p *int = &i
var fp *float32 = (*float32)(unsafe.Pointer(p))
*fp = *fp * 10     //int类型的指针被转换成了 float32
fmt.Println(i)  // 100
```
  这个示例说明了 unsafe.Pointer 是一个万能指针，可以在任何指针类型之间做转化，这就绕过了 Go 的类型安全机制，所以是不安全的操作。

#### 指针运算实现
  此外，根据上面的转化规则 3、4，unsafe.Pointer 还可以与 uintptr 类型之间相互转化，为什么要单独列出这个类型呢？

  uintptr 是 Go 内置的可用于存储指针的整型，而整型是可以进行数学运算的！因此，将 unsafe.Pointer 转化为 uintptr 类型后，就可以让本不具备运算能力的指针具备了指针运算能力：

``` golang

arr := [3]int{1, 2, 3}
ap := &arr
sp := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(ap)) + unsafe.Sizeof(arr[0])))
*sp += 3
fmt.Println(arr)

```
> 这里，我们将数组 arr 的内存地址赋值给指针 ap，然后通过 unsafe.Pointer 这个桥梁转化为 uintptr 类型，再加上数组元素偏移量（通过 unsafe.Sizeof 函数获取），就可以得到该数组第二个元素的内存地址，最后通过 unsafe.Pointer 将其转化为 int 类型指针赋值给 sp 指针，并进行修改，最终打印的结果是： [1 5 3]
> 这里好tm麻烦 绕来绕去的 一定避免这种嵌套好几层的 写法
> 可以绕过 Go 指针的安全限制，实现对指针的动态偏移和计算了，这会导致即使发生数组越界了，也不会报错，而是返回下一个内存地址存储的值，这就破坏了内存安全限制，所以这也是不安全的操作，我们在实际编码时要尽量避免使用，必须使用的话也要非常谨慎。

# 流程控制
## 概述
  流程控制主要用于设定计算执行的次序，建立程序的逻辑结构。Go 语言的流程控制和其他编程语言类似，支持如下几种流程控制语句：

  - 条件语句：用于条件判断，对应的关键字有 if、else 和 else if；
  - 分支语句：用于分支选择，对应的关键字有 switch、case 和 select（用于通道);
  - 循环语句：用于循环迭代，对应的关键字有 for 和 range
  - 跳转语句：用于代码跳转，对应的关键字有 goto

## 条件语句

``` golang
// if
if condition { 
    // do something 
}

// if...else...
if condition { 
    // do something 
} else {
    // do something 
}


// if...else if...else...
if condition1 { 
    // do something 
} else if condition2 {
    // do something else 
} else {
    // catch-all or default 
}
```
### 注意事项
- 条件语句不需要使用圆括号将条件包含起来
- 无论语句体内有几条语句，花括号 {} 都是必须存在的；
- 左花括号 { 必须与 if 或者 else 处于同一行；
- 在 if 之后，条件语句之前，可以添加变量初始化语句，使用 ; 间隔，比如上述代码可以这么写 if score := 100; score > 90 {

## 分支语句
  Go 语言的分支语句和其他编程语言类似，只是不需要在每个分支结构中显式通过 break 语句退出：
``` golang
score := 100
switch score {
case 90, 100:
    fmt.Println("Grade: A")
case 80:
    fmt.Println("Grade: B")
case 70:
    fmt.Println("Grade: C")
case 60:
case 65:
    fmt.Println("Grade: D")
default:
    fmt.Println("Grade: F")
}
//1.case 可以写表达式  也可以 直接写值
```
### 合并分支
  在 Go 语言中，我们可以用逗号分隔不同的分支条件来达到合并分支语句的目的，如 case 90,100，而不能像其它语言那样，通过多个相邻的 case 语句来合并相同的分支语句，比如上面的 case 60 和 case 65，因为 case 60 这个分支语句在 Go 语言中会被认为是空语句，直接退出了。
  
  Go 分支语句中比较有意思的一点，那就是不需要显式通过 break 语句退出某个分支，上一个分支语句代码会在下一个 case 语句出现之前自动退出，如果你想要继续执行后续分支代码，可以通过一个 fallthrough 语句来声明：

``` golang
score := 60
switch score {
...
case 60:
    fallthrough
case 65:
    fmt.Println("Grade: D")
...
}
```

### 注意事项
- 和条件语句一样，左花括号 { 必须与 switch 处于同一行
- 单个 case 中，可以出现多个结果选项（通过逗号分隔）
- 与其它语言不同，Go 语言不需要用 break 来明确退出一个 case
- 只有在 case 中明确添加 fallthrough 关键字，才会继续执行紧跟的下一个 case；
- 可以不设定 switch 之后的条件表达式，在这种情况下，整个 switch 结构与多个 if...else... 的逻辑作用等同

## 循环语句

### for 循环
#### 基本使用
  其它编程语言不同的是，Go 语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构。关键字 for 的基本使用方法与其他语言类似，只是循环条件不含括号，比如我们要计算 1 到 100 之间所有数字之和，可以这么做：

``` golang
sum := 0 
for i := 1; i <= 100; i++ { 
    sum += i 
}
fmt.Println(sum)
```
#### 无限循环
  Go 语言不支持 while 和 do-while 循环语句，对于无限循环场景，可以通过不带循环条件的 for 语句实现，下面我们通过无限循环来改写上述计算 1 到 100 以内数字之和的实现如下：
``` golang
sum := 0
i := 0
for {
    i++
    if i > 100 {
        break
    }
    sum += i
}
fmt.Println(sum)
//可以通过 break 语句来中断无限循环
```

#### 多重赋值
  此外，在 for 循环条件表达式中也支持多重赋值，我们可以通过这一特性快速实现数组/切片内首尾元素的交换3
``` golang

a := []int{1, 2, 3, 4, 5, 6} 
for i, j := 0, len(a) – 1; i < j; i, j = i + 1, j – 1 { 
    a[i], a[j] = a[j], a[i] 
}
fmt.Println(a)

```

### for-range 结构
  另外，对于可迭代的集合（数组、切片、字典），Go 语言还支持通过 for-range 结构对其进行循环遍历

``` golang

for k, v := range a {
    fmt.Println(k, v)
}

//要忽略索引/键，可以这么做：
for _, v := range a {
    fmt.Println(v)
}

```

### 基于条件判断进行循环
``` golang
sum := 0
i := 0
for i < 100 {
    i++
    sum += i
}
fmt.Println(sum)
```
###

- 和条件语句、分支语句一样，左花括号 { 必须与 for 处于同一行；
- 不支持 whie 和 do-while 结构的循环语句；
- 可以通过 for-range 结构对可迭代集合进行遍历；
- 支持基于条件判断进行循环迭代；
- 允许在循环条件中定义和初始化变量，且支持多重赋值；
- Go 语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例： mysql存储过程中 也可以这样

``` golang
JLoop: 
for j := 0; j < 5; j++ { 
    for i := 0; i < 10; i++ { 
        if i > 5 { 
            break JLoop
        }
        fmt.Println(i)
    } 
} 
```

## 跳转语句

### break 与 continue 语句
  Go 语言支持在循环语句中通过 break 语句跳出循环，通过 continue 语句进入下一个循环。
  break 的默认作用范围是该语句所在的最内部的循环体：
#### 标签 
  Go 语言的 break 和 contine 与其他语言的不同之处在于支持与标签结合跳转到指定的标签语句，从而改变这两个语句的默认跳转逻辑，标签语句通过  标签 + : 进行声明：
``` golang

arr := [][]int{{1,2,3},{4,5,6},{7,8,9}}
ITERATOR1:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        num := arr[i][j]
        if j > 1 {
            break ITERATOR1
        }
        fmt.Println(num)
    }
}
//这里打印结果会是 1 ,2  不是很理解 
// 妈的没仔细看  判断的不是num > 1是 j>1

```
### goto 语句
  goto 语句被多数语言学者所反对，告诫大家不要使用，因为很容易造成代码逻辑混乱，进而导致不易发现的 bug。但 Go 语言仍然支持 goto 关键字，goto 语句的语义非常简单，就是跳转到本函数内的某个标签


# Go 函数式编程篇（一）：函数使用入门和常用内置函数介绍
在 Go 语言中，函数主要有三种类型：
- 普通函数
- 匿名函数（闭包）
- 类方法


## 函数定义
  Go 普通函数的基本组成包括：关键字 func、函数名、参数列表、返回值、函数体和返回语句。作为强类型语言，无论是参数还是返回值，在定义函数时，都要声明其类型：





java 可以封装一个查询对象  例如 UserQuery 里面有分页参数 有排序字段传递 有 正序倒序 这样可以用实体类接收对象 也不会把无关字段 写到实体类中